var documenterSearchIndex = {"docs":
[{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\n    # Solve nonlinear problem to display Ipopt initial message\n    dearussell([1; 2; 3], [1; 1; 1], orient = :Graph, rts = :VRS)\nend","category":"page"},{"location":"technical/russell/#Russell-Models","page":"Russell Models","title":"Russell Models","text":"","category":"section"},{"location":"technical/russell/#Russell-Input-Model","page":"Russell Models","title":"Russell Input Model","text":"","category":"section"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"Based on the data  matrix (XY), we calculate the Russell measure of input efficiency (Färe & Lovell, 1978; and Färe et al., 1985) of each observation o by solving n times the following linear programming problem:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"beginaligned\n   undersettheta_i lambda_j mathopmin quad quad quad  frac1m sum_i=1^mtheta_i  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le theta_i x_io qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge y_ro qquad r = 1s \n   quad quad quad quad quad  theta_i le 1 qquad i = 1m  \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"The measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"In this example we compute the Russell input DEA model under constant returns to scale:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> using DataEnvelopmentAnalysis\n\njulia> X = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\njulia> Y = [1; 1; 1; 1; 1; 1; 1; 1];\n\njulia> dearussell(X, Y, orient = :Input, rts = :CRS)\nRussell DEA Model \nDMUs = 8; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = CRS\n──────────────────────────────────────────\n   efficiency     effX1     effX2  slackY1\n──────────────────────────────────────────\n1    1.0       1.0       1.0           0.0\n2    1.0       1.0       1.0           0.0\n3    1.0       1.0       1.0           0.0\n4    0.583333  0.5       0.666667      0.0\n5    0.4       0.4       0.4           0.0\n6    0.833333  0.666667  1.0           0.0\n7    0.65      0.5       0.8           0.0\n8    0.5625    0.625     0.5           0.0\n──────────────────────────────────────────","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"To compute the variable returns to scale model, we simply set the rts parameter to :VRS:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> dearussellio = dearussell(X, Y, orient = :Input, rts = :CRS);\n\njulia> efficiency(dearussellio)\n8-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 0.5833333333333334\n 0.4\n 0.8333333333333334\n 0.65\n 0.5625\n\njulia> efficiency(dearussellio, :X)\n8×2 Matrix{Float64}:\n 1.0       1.0\n 1.0       1.0\n 1.0       1.0\n 0.5       0.666667\n 0.4       0.4\n 0.666667  1.0\n 0.5       0.8\n 0.625     0.5","category":"page"},{"location":"technical/russell/#Russell-Output-Model","page":"Russell Models","title":"Russell Output Model","text":"","category":"section"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"It is possible to calculate the Russell measure of output efficiency of each observation by solving the following linear program:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"beginaligned\n   undersetphi_r lambda_j mathopmax quad quad quad  frac1s sum_r=1^sphi_r  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le x_io qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge phi_r y_ro qquad r = 1s \n   quad quad quad quad quad  phi_r ge 1 qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"with the following condition when assuming variable returns to scale:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"In this example we compute the Russell output DEA model under constant returns to scale:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> X = [1; 1; 1; 1; 1; 1; 1; 1];\n\njulia> Y = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5] ;\n\njulia> dearussell(X, Y, orient = :Output, rts = :CRS)\nRussell DEA Model \nDMUs = 8; Inputs = 1; Outputs = 2\nOrientation = Output; Returns to Scale = CRS\n────────────────────────────────────────\n   efficiency    effY1    effY2  slackX1\n────────────────────────────────────────\n1     1.0      1.0      1.0          0.0\n2     1.0      1.0      1.0          0.0\n3     1.0      1.0      1.0          0.0\n4     1.86667  2.33333  1.4          0.0\n5     2.33333  2.33333  2.33333      0.0\n6     1.5      1.0      2.0          0.0\n7     1.45833  1.16667  1.75         0.0\n8     3.05556  5.11111  1.0          0.0\n────────────────────────────────────────","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> dearusselloo = dearussell(X, Y, orient = :Output, rts = :CRS);\n\njulia> efficiency(dearusselloo)\n8-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.8666666666666665\n 2.333333333333333\n 1.5\n 1.4583333333333335\n 3.0555555555555554\n\njulia> efficiency(dearusselloo, :Y)\n8×2 Matrix{Float64}:\n 1.0      1.0\n 1.0      1.0\n 1.0      1.0\n 2.33333  1.4\n 2.33333  2.33333\n 1.0      2.0\n 1.16667  1.75\n 5.11111  1.0","category":"page"},{"location":"technical/russell/#Russell-Graph-Model","page":"Russell Models","title":"Russell Graph Model","text":"","category":"section"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"It is possible to calculate the Russell graph measure of technical efficiency of each observation by solving the following linear program:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"beginaligned\n   undersettheta_i phi_r lambda_j mathopmin quad quad quad  frac1m + s (sum_i=1^mtheta_i +  sum_r=1^sfrac1phi_r)  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le theta_i x_io  qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge phi_r y_ro qquad r = 1s \n   quad quad quad quad quad  theta_i le 1 qquad i = 1m  \n   quad quad quad quad quad  phi_r ge 1 qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"with the following condition when assuming variable returns to scale:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"In this example we compute the Russell graph DEA model under variable returns to scale:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> dearussell(X, Y, orient = :Graph, rts = :VRS)\nRussell DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n────────────────────────────────\n   efficiency     effX1    effY1\n────────────────────────────────\n1    1.0       1.0       1.0\n2    1.0       1.0       1.0\n3    1.0       1.0       1.0\n4    1.0       1.0       1.0\n5    0.633333  0.666667  1.66667\n6    0.723214  0.571429  1.14286\n7    0.928571  0.857143  1.0\n8    0.447795  0.424989  2.12495\n────────────────────────────────","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"julia> dearussellgr = dearussell(X, Y, orient = :Graph, rts = :VRS);\n\njulia> efficiency(dearussellgr)\n8-element Vector{Float64}:\n 0.9999996498270471\n 0.9999999750859099\n 0.9999999915100868\n 0.9999999701380229\n 0.6333333226351024\n 0.7232142937165499\n 0.9285714048852067\n 0.4477946881737884\n\njulia> efficiency(dearussellgr, :X)\n8×1 Matrix{Float64}:\n 1.0\n 0.9999999528133661\n 0.9999999786181379\n 0.9999999323682799\n 0.6666666303008444\n 0.5714285155047499\n 0.8571428024463076\n 0.42498937010375143\n\njulia> efficiency(dearussellgr, :Y)\n8×1 Matrix{Float64}:\n 1.0000007087196852\n 1.0000000026415463\n 1.0\n 1.0\n 1.6666666250851108\n 1.1428570489099181\n 1.0\n 2.124946848134728","category":"page"},{"location":"technical/russell/#dearussell-Function-Documentation","page":"Russell Models","title":"dearussell Function Documentation","text":"","category":"section"},{"location":"technical/russell/","page":"Russell Models","title":"Russell Models","text":"dearussell","category":"page"},{"location":"technical/russell/#DataEnvelopmentAnalysis.dearussell","page":"Russell Models","title":"DataEnvelopmentAnalysis.dearussell","text":"dearussell(X, Y)\n\nCompute the Russell model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the Russell input mode. For the Russell output model choose :Output. For the Russell graph model choose :Graph.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> dearussell(X, Y, rts = :VRS)\nRussell DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = VRS\n───────────────────────────────────────────────\n    efficiency     effX1     effX2      slackY1\n───────────────────────────────────────────────\n1     1.0       1.0       1.0       0.0\n2     0.79386   0.587719  1.0       9.88357e-15\n3     1.0       1.0       1.0       0.0\n4     1.0       1.0       1.0       0.0\n5     0.603175  0.277778  0.928571  4.0\n6     1.0       1.0       1.0       3.78178e-16\n7     1.0       1.0       1.0       0.0\n8     1.0       1.0       1.0       0.0\n9     1.0       1.0       1.0       0.0\n10    0.485746  0.563492  0.408     0.0\n11    0.882353  1.0       0.764706  0.0\n───────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/enhancedrussell/#Enhanced-Russell-Graph-Slack-Based-Measure","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"","category":"section"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"Based on the data  matrix (XY), we calculate the Enhanced Russell Graph Measure, ERG, (Pastor et al., 1999) – also known as the Slack Based Measure, SBM, Tone (2001) – of each observation o by solving n times the following linear programming problem:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"beginaligned\n   undersetbeta t_i^- t_r^+ mu_j mathopmin quad quad quad  beta -  frac1m sum_i=1^mfract_i^-x_io  \n   textsubject textto  \n   quad quad quad quad quad  beta +  frac1s sum_r=1^sfract_r^+y_ro = 1 \n   quad quad quad quad quad  sum_j=1^nmu_j x_ij  = beta x_io - t_i^- qquad i = 1m \n   quad quad quad quad quad  sum_j=1^nmu_j y_rj  = beta y_ro + t_r^+ qquad r = 1s \n   quad quad quad quad quad  beta ge 0  \n   quad quad quad quad quad  t_i^- ge 0 qquad i = 1m \n   quad quad quad quad quad  t_r^+ ge 0 qquad r = 1s \n   quad quad quad quad quad  mu_j ge 0 qquad j = 1n \nendaligned","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"with the following condition when assuming variable returns to scale:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"sumnolimits_j=1^nmu_j=beta","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"After solving the model, input and output slacks are recovered through the following expressions:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"beginaligned\n  s_i^- = fract_i^-beta qquad i = 1m \n  s_r^+ = fract_r^+beta qquad r = 1s\nendaligned","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"In this example we compute the Enhanced Russell Graph DEA model under variable returns to scale:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"julia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> deaerg(X, Y, rts = :VRS)\nEnhanced Russell Graph Slack Based Measure DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n───────────────────────────────────────\n   efficiency    beta  slackX1  slackY1\n───────────────────────────────────────\n1    1.0       1.0     0.0        0.0\n2    1.0       1.0     0.0        0.0\n3    1.0       1.0     0.0        0.0\n4    1.0       1.0     0.0        0.0\n5    0.4       0.6     2.0        2.0\n6    0.47619   1.0     7.33333    0.0\n7    0.857143  1.0     2.0        0.0\n8    0.2       0.4706  5.412      2.647\n───────────────────────────────────────","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"julia> deaergvrs = deaerg(X, Y, rts = :VRS);\n\njulia> efficiency(deaergvrs)\n8-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 0.39999999999999997\n 0.47619047619047616\n 0.8571428571428574\n 0.2","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"Estimated beta's are returned with the efficiency function using :beta as the second argument:","category":"page"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"julia> efficiency(deaergvrs, :beta)\n8-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 0.6\n 0.9999999999999998\n 0.9999999999999998\n 0.4706000000000001","category":"page"},{"location":"technical/enhancedrussell/#deaerg-Function-Documentation","page":"Enhanced Russell Graph Slack Based Measure","title":"deaerg Function Documentation","text":"","category":"section"},{"location":"technical/enhancedrussell/","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"deaerg","category":"page"},{"location":"technical/enhancedrussell/#DataEnvelopmentAnalysis.deaerg","page":"Enhanced Russell Graph Slack Based Measure","title":"DataEnvelopmentAnalysis.deaerg","text":"deaerg(X, Y)\n\nCompute data envelopment analysis Enhanced Russell Graph Slack Based Measure for inputs X and outputs Y.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353] ;\n\njulia> deaerg(X, Y, rts = :VRS)\nEnhanced Russell Graph Slack Based Measure DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n───────────────────────────────────────\n   efficiency    beta  slackX1  slackY1\n───────────────────────────────────────\n1    1.0       1.0     0.0        0.0\n2    1.0       1.0     0.0        0.0\n3    1.0       1.0     0.0        0.0\n4    1.0       1.0     0.0        0.0\n5    0.4       0.6     2.0        2.0\n6    0.47619   1.0     7.33333    0.0\n7    0.857143  1.0     2.0        0.0\n8    0.2       0.4706  5.412      2.647\n───────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\n    # Solve nonlinear problem to display Ipopt initial message\n    X = [1; 2; 3];\n    Y = [1; 1; 1];\n    deagdf(X, Y, alpha = 0.5, rts = :VRS)\nend","category":"page"},{"location":"economic/profitability/#Profitability-Models","page":"Profitability Models","title":"Profitability Models","text":"","category":"section"},{"location":"economic/profitability/#Profitability-Model","page":"Profitability Models","title":"Profitability Model","text":"","category":"section"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"The profitabilty function defines as mathrmPleft(mathbfwmathbfpright)=max Big sumlimits_i=1^sp_iy_isumlimits_i=1^mw_ix_i   mathbfx geqslant Xmathbflambdamathbfy leqslant Ymathbflambda  lambda  geqslant mathbf0 Big. Zofío and Prieto (2006) introduced the following program that allows calculating profitability efficiency.","category":"page"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"beginaligned\n  undersetmathbfxylambda_jomega mathopmin quad quad quad  omega  \n  textsubject textto \n  quad quad quad quad quad  sum_j=1^j lambda^j fracw^j x^jp^j y^j = omega fracw^j x^j_op^j y^j_o  \n  quad quad quad quad quad   sumnolimits_j=1^nlambda^j=1 \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned","category":"page"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"Profitabilty efficiency defines as the ratio between maximum profitabilty and observed profitabilty. Following the duality results introduced by Zofío and Prieto (2006) it is possible to decompose it into technical and allocative efficiencies under constant returns to scale. Profitabilty efficiency can be then decomposed into the generalizaed distance fucntion and the residual ratio corresponding to the allocative profit efficiency. Allocative efficiency defines then as the ratio of profitability at the technically efficient projection on the frontier to maximum profitability.","category":"page"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"In this example we compute the profitability efficiency measure:","category":"page"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"julia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\njulia> deaprofitability(X, Y, W, P)\nProfitability DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nalpha = 0.5; Returns to Scale = VRS\n─────────────────────────────────────────────────────────\n   Profitability       CRS      VRS     Scale  Allocative\n─────────────────────────────────────────────────────────\n1       0.38796   0.636364  0.68185  0.93329     0.609651\n2       1.0       1.0       1.0      1.0         1.0\n3       0.765217  1.0       1.0      1.0         0.765217\n4       0.25      0.25      0.25     1.0         1.0\n5       0.15879   0.26087   0.36     0.724638    0.608696\n─────────────────────────────────────────────────────────","category":"page"},{"location":"economic/profitability/#deaprofitability-Function-Documentation","page":"Profitability Models","title":"deaprofitability Function Documentation","text":"","category":"section"},{"location":"economic/profitability/","page":"Profitability Models","title":"Profitability Models","text":"deaprofitability","category":"page"},{"location":"economic/profitability/#DataEnvelopmentAnalysis.deaprofitability","page":"Profitability Models","title":"DataEnvelopmentAnalysis.deaprofitability","text":"deaprofitability(X, Y, W, P)\n\nCompute profitability efficiency using data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nalpha=0.5: alpha to use for the generalized distance function.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\njulia> deaprofitability(X, Y, W, P)\nProfitability DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nalpha = 0.5; Returns to Scale = VRS\n─────────────────────────────────────────────────────────\n   Profitability       CRS      VRS     Scale  Allocative\n─────────────────────────────────────────────────────────\n1       0.38796   0.636364  0.68185  0.93329     0.609651\n2       1.0       1.0       1.0      1.0         1.0\n3       0.765217  1.0       1.0      1.0         0.765217\n4       0.25      0.25      0.25     1.0         1.0\n5       0.15879   0.26087   0.36     0.724638    0.608696\n─────────────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/holder/#Hölder-Distance-Function-Models","page":"Hölder Distance Function","title":"Hölder Distance Function Models","text":"","category":"section"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"Briec (1998) defined technical inefficiency using Hölder norms.","category":"page"},{"location":"technical/holder/#Hölder-L1","page":"Hölder Distance Function","title":"Hölder L1","text":"","category":"section"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"In this example we compute the Hölder L1 DEA model under varible returns to scale:","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"julia> using DataEnvelopmentAnalysis\n\njulia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> deaholder(X, Y, l = 1, rts = :VRS)\nHölder L1 DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n────────────────────────────────────────────────\n   efficiency  minimum      slackX1      slackY1\n────────────────────────────────────────────────\n1         0.0       X1  0.0          0.0\n2         0.0       X1  0.0          0.0\n3         0.0       X1  0.0          0.0\n4         0.0       X1  0.0          0.0\n5         3.0       X1  0.0          1.01506e-15\n6         2.0       Y1  2.0          0.0\n7         0.0       Y1  2.0          0.0\n8         6.0       Y1  1.77636e-15  0.0\n────────────────────────────────────────────────","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"julia> holderl1 = deaholder(X, Y, l = 1, rts = :VRS);\n\njulia> efficiency(holderl1)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 2.9999999999999996\n 2.000000000000001\n 0.0\n 6.0","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"The input or output that determines the projection to the frontier is returned with:","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"julia> efficiency(holderl1, :min)\n8-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n 2\n 2\n 2","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"with inputs and outputs numbered sequentially.","category":"page"},{"location":"technical/holder/#Hölder-L2","page":"Hölder Distance Function","title":"Hölder L2","text":"","category":"section"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"warning: Requieres a solver that supports SOS constraints\nThe Hölder L2 model requieres a solver that supports SOS constraints, such as Gurobi. Solving the model with Ipopt will return invalid results.","category":"page"},{"location":"technical/holder/#Hölder-LInf","page":"Hölder Distance Function","title":"Hölder LInf","text":"","category":"section"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"In this example we compute the Hölder LInf DEA model under varible returns to scale:","category":"page"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"julia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> deaholder(X, Y, l = Inf, rts = :VRS)\nHölder LInf DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n────────────────────────────────────────\n   efficiency      slackX1       slackY1\n────────────────────────────────────────\n1       0.0    0.0           0.0\n2       0.0    0.0           0.0\n3       0.0    0.0           0.0\n4       0.0    0.0           0.0\n5       2.0    0.0          -8.08877e-16\n6       2.0    0.0           0.0\n7       0.0    2.0           0.0\n8       3.832  2.96059e-16   0.0\n────────────────────────────────────────","category":"page"},{"location":"technical/holder/#deaholder-Function-Documentation","page":"Hölder Distance Function","title":"deaholder Function Documentation","text":"","category":"section"},{"location":"technical/holder/","page":"Hölder Distance Function","title":"Hölder Distance Function","text":"deaholder","category":"page"},{"location":"technical/holder/#DataEnvelopmentAnalysis.deaholder","page":"Hölder Distance Function","title":"DataEnvelopmentAnalysis.deaholder","text":"deaholder(X, Y; l)\n\nCompute the Hölder distance function model using data envelopment analysis for inputs X and outputs Y,  using Hölder norm l.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> deaholder(X, Y, l = 1, rts = :VRS)\nHölder L1 DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\n────────────────────────────────────────────────\n   efficiency  minimum      slackX1      slackY1\n────────────────────────────────────────────────\n1         0.0       X1  0.0          0.0\n2         0.0       X1  0.0          0.0\n3         0.0       X1  0.0          0.0\n4         0.0       X1  0.0          0.0\n5         3.0       X1  0.0          1.01506e-15\n6         2.0       Y1  2.0          0.0\n7         0.0       Y1  2.0          0.0\n8         6.0       Y1  1.77636e-15  0.0\n────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\n    # Solve nonlinear problem to display Ipopt initial message\n    X = [1; 2; 3];\n    Y = [1; 1; 1];\n    deagdf(X, Y, alpha = 0.5, rts = :VRS)\nend","category":"page"},{"location":"technical/generalizeddf/#Generalized-Distance-Function-Models","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"","category":"section"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"Chavas and Cox (1999) introduced a generalized distance function efficiency measure that reescales both inputs and outputs toward the frontier technology.","category":"page"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"beginaligned\n  undersetdelta mathbflambda mathopmin quad quad quad  delta  \n  textsubject textto \n  quad quad quad quad quad  Xmathbflambda  le delta^1 - alpha mathbfx_o \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy_o  delta^alpha \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned","category":"page"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"The measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:","category":"page"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"In this example we compute the generalized distance function DEA model under variable returns to scale using 05 for the value of alpha:","category":"page"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"julia> X = [5 3; 2 4; 4 2; 4 8; 7 9];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6];\n\njulia> deagdf(X, Y, alpha = 0.5, rts = :VRS, slack = false)\nGeneralized DF DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nalpha = 0.5; Returns to Scale = VRS\n─────────────\n   efficiency\n─────────────\n1     0.68185\n2     1.0\n3     1.0\n4     0.25\n5     0.36\n─────────────","category":"page"},{"location":"technical/generalizeddf/#deagdf-Function-Documentation","page":"Generalized Distance Function Models","title":"deagdf Function Documentation","text":"","category":"section"},{"location":"technical/generalizeddf/","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"deagdf","category":"page"},{"location":"technical/generalizeddf/#DataEnvelopmentAnalysis.deagdf","page":"Generalized Distance Function Models","title":"DataEnvelopmentAnalysis.deagdf","text":"deagdf(X, Y, alpha)\n\nCompute generalized distance function data envelopment analysis model for inputs X, outputs Y, and alpha.\n\nOptional Arguments\n\nalpha=0.5: alpha value.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: compute input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6];\n\njulia> deagdf(X, Y, alpha = 0.5, rts = :VRS)\nGeneralized DF DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nalpha = 0.5; Returns to Scale = VRS\n─────────────────────────────────────────────────────────────\n   efficiency     slackX1     slackX2     slackY1     slackY2\n─────────────────────────────────────────────────────────────\n1     0.68185  0.605935    4.26672e-8  3.91163e-8  4.67865\n2     1.0      5.34772e-8  6.70059e-8  2.7034e-8   4.8232e-8\n3     1.0      4.82929e-8  7.26916e-8  6.00225e-8  1.66806e-8\n4     0.25     4.6491e-8   9.94558e-8  5.39305e-8  9.75587e-8\n5     0.36     0.2         3.4         3.0         8.07052e-8\n─────────────────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"economic/profit/#Profit-Models","page":"Profit Models","title":"Profit Models","text":"","category":"section"},{"location":"economic/profit/#Profit-Efficiency-Model-with-Directional-Distance-Function-Technical-Efficiency","page":"Profit Models","title":"Profit Efficiency Model with Directional Distance Function Technical Efficiency","text":"","category":"section"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"The profit function defines as Pileft(mathbfwmathbfpright)=max Big sumlimits_i=1^sp_iy_i-sumlimits_i=1^mw_ix_i      mathbfx geqslant Xmathbflambdamathbfy leqslant Ymathbflambda mathbfmathbfelambda=1 lambda  geqslant mathbf0 Big. Calculating maximum profit along with the optimal output and input quantities mathbfy^*and mathbfx^* requires solving:","category":"page"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"beginaligned\n  undersetmathbfxylambda mathopmax quad quad quad  Pileft(mathbfwmathbfpright)=mathbfpy^*-wx^*  \n  textsubject textto \n  quad quad quad quad quad  mathbfxge Xmathbflambda=x  \n  quad quad quad quad quad   mathbfy  le Ymathbflambda =y \n  quad quad quad quad quad  mathbfelambda=1 \n  quad quad quad quad quad  mathbflambda ge mathbf0  \nendaligned","category":"page"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"Profit efficiency defines as the difference between maximum profit and observed profit. Following the duality results introduced by Chambers, Chung and Färe (1998) it is possible to decompose it into technical and allocative efficiencies under variable returns to scale. Profit efficiency can be then decomposed into the directional distance fucntion and the residual difference corresponding to the allocative profit efficiency. Allocative efficiency defines then as the difference between maximum profit and profit at the technically efficient projection on the frontier. The approach relies on the directional vector to normalize these components, thereby ensuring that their values can be compared across DMUs.","category":"page"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"In this example we compute the profit efficiency measure under variable returns to scale:","category":"page"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"julia> X = [1 1; 1 1; 0.75 1.5; 0.5 2; 0.5 2; 2 2; 2.75 3.5; 1.375 1.75];\n\njulia> Y = [1 11; 5 3; 5 5; 2 9; 4 5; 4 2; 3 3; 4.5 3.5];\n\njulia> P = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\njulia> deaprofit(X, Y, W, P, Gx = :Monetary, Gy = :Monetary)\nProfit DEA Model \nDMUs = 8; Inputs = 2; Outputs = 2\nReturns to Scale = VRS\nGx = Monetary; Gy = Monetary\n─────────────────────────────────────\n   Profit     Technical    Allocative\n─────────────────────────────────────\n1     2.0   0.0           2.0\n2     2.0  -5.41234e-16   2.0\n3     0.0   0.0           0.0\n4     2.0   0.0           2.0\n5     2.0   0.0           2.0\n6     8.0   6.0           2.0\n7    12.0  12.0          -1.77636e-15\n8     4.0   3.0           1.0\n─────────────────────────────────────","category":"page"},{"location":"economic/profit/#deaprofit-Function-Documentation","page":"Profit Models","title":"deaprofit Function Documentation","text":"","category":"section"},{"location":"economic/profit/","page":"Profit Models","title":"Profit Models","text":"deaprofit","category":"page"},{"location":"economic/profit/#DataEnvelopmentAnalysis.deaprofit","page":"Profit Models","title":"DataEnvelopmentAnalysis.deaprofit","text":"deaprofit(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency using data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [1 1; 1 1; 0.75 1.5; 0.5 2; 0.5 2; 2 2; 2.75 3.5; 1.375 1.75];\n\njulia> Y = [1 11; 5 3; 5 5; 2 9; 4 5; 4 2; 3 3; 4.5 3.5];\n\njulia> P = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\njulia> deaprofit(X, Y, W, P, Gx = :Monetary, Gy = :Monetary)\nProfit DEA Model \nDMUs = 8; Inputs = 2; Outputs = 2\nReturns to Scale = VRS\nGx = Monetary; Gy = Monetary\n─────────────────────────────────────\n   Profit     Technical    Allocative\n─────────────────────────────────────\n1     2.0   0.0           2.0\n2     2.0  -5.41234e-16   2.0\n3     0.0   0.0           0.0\n4     2.0   0.0           2.0\n5     2.0   0.0           2.0\n6     8.0   6.0           2.0\n7    12.0  12.0          -1.77636e-15\n8     4.0   3.0           1.0\n─────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/","page":"Common functions for technical models","title":"Common functions for technical models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/commontechnical/#Common-functions-for-technical-models","page":"Common functions for technical models","title":"Common functions for technical models","text":"","category":"section"},{"location":"technical/commontechnical/","page":"Common functions for technical models","title":"Common functions for technical models","text":"nobs(::AbstractDEAModel)\nninputs(::AbstractDEAModel) \nnoutputs(::AbstractDEAModel) \nBase.names(::AbstractDEAModel)\nefficiency(::AbstractTechnicalDEAModel)\nslacks\ntargets(::AbstractTechnicalDEAModel, ::Symbol)\npeers\npeersmatrix\nispeer\nmultipliers\nrts","category":"page"},{"location":"technical/commontechnical/#StatsBase.nobs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"StatsBase.nobs","text":"nbos(model::Abstract DEAModel)\n\nReturn number of observations of a DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> nobs(deaio)\n11\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.ninputs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.ninputs","text":"ninputs(model::AbstractDEAModel)\n\nReturn number of inputs of a DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> ninputs(deaio)\n2\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.noutputs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.noutputs","text":"noutputs(model::AbstractDEAModel)\n\nReturn number of outputs of a DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> noutputs(deaio)\n1\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#Base.names-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"Base.names","text":"names(model::AbstractDEAModel)\n\nReturn the names of the decision making units (DMUs)\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> dmunames = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\"]\n\njulia> deaio = dea(X, Y, names = dmunames);\n\njulia> names(deaio)\n11-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"D\"\n ⋮\n \"H\"\n \"I\"\n \"J\"\n \"K\"\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.efficiency-Tuple{AbstractTechnicalDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.efficiency","text":"efficiency(model::AbstractTechnicalDEAModel)\n\nReturn efficiency scores of a technical DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> efficiency(deaio)\n11-element Vector{Float64}:\n 1.0\n 0.6222896790980051\n 0.8198562443845464\n 1.0\n ⋮\n 0.7576690895651103\n 0.8201058201058201\n 0.49056603773584917\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.slacks","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.slacks","text":"slacks(model::AbstractTechnicalDEAModel, slack::Symbol)\n\nReturn slacks of a technical DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> slacks(deaio, :X)\n11×2 Matrix{Float64}:\n  0.0          0.0\n -4.41868e-15  0.0\n  0.0          8.17926e-15\n -8.03397e-16  0.0\n  ⋮            \n  1.60679e-15  0.0\n  1.64021      0.0\n  9.68683e-15  0.0\n  0.0          4.0\n\njulia> slacks(deaio, :Y)\n11×1 Matrix{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.targets-Tuple{AbstractTechnicalDEAModel, Symbol}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.targets","text":"targets(model::AbstractTechnicalDEAModel, target::Symbol)\n\nReturn targets of a technical DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> targets(deaio, :X)\n11×2 Matrix{Float64}:\n  5.0      13.0\n  9.95663   7.46748\n 13.1177   21.3163\n 17.0      15.0\n  ⋮        \n 20.4571   16.6687\n 28.7037   11.4815\n 20.6038   12.2642\n  5.0      13.0\n\njulia> targets(deaio, :Y)\n11×1 Matrix{Float64}:\n 12.0\n 14.0\n 25.0\n 26.0\n  ⋮\n 30.0\n 31.0\n 26.0\n 12.0\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.peers","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.peers","text":"peers(model::AbstractDEAModel)\n\nReturn peers of a DEA model.\n\nOptional Arguments\n\natol=1e-10: tolerance for zero values.\nnamesref: a vector of strings with the names of the decision making units in the reference set.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> peers(deaio)\nDEA Peers\n1: 1 ( 1.0 ) \n2: 4 ( 0.424978317432784 ) 7 ( 0.10928013876843023 ) \n3: 1 ( 1.134321653189578 ) 4 ( 0.43800539083557943 ) \n4: 4 ( 1.0 ) \n5: 4 ( 0.25738077214231636 ) 7 ( 0.04844814534443607 ) \n6: 7 ( 0.3333333333333333 ) \n7: 7 ( 1.0 ) \n8: 4 ( 1.0348650979425895 ) 7 ( 0.11457435012935832 ) \n9: 7 ( 1.1481481481481481 ) \n10: 4 ( 0.49056603773584906 ) 7 ( 0.4905660377358491 ) \n11: 11 ( 1.0 ) \n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.peersmatrix","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.peersmatrix","text":"peersmatrix(model::AbstractDEAModel)\n\nReturn peers matrix of a DEA model.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaio = dea(X, Y);\n\njulia> peersmatrix(deaio)\n11×11 SparseMatrixCSC{Float64, Int64} with 17 stored entries:\n 1.0       ⋅    ⋅    ⋅         ⋅    ⋅    ⋅            ⋅    ⋅    ⋅    ⋅ \n  ⋅        ⋅    ⋅   0.424978   ⋅    ⋅   0.10928       ⋅    ⋅    ⋅    ⋅ \n 1.13432   ⋅    ⋅   0.438005   ⋅    ⋅    ⋅            ⋅    ⋅    ⋅    ⋅ \n  ⋅        ⋅    ⋅   1.0        ⋅    ⋅   1.48479e-16   ⋅    ⋅    ⋅    ⋅ \n ⋮                                 ⋮                                ⋮\n  ⋅        ⋅    ⋅   1.03487    ⋅    ⋅   0.114574      ⋅    ⋅    ⋅    ⋅ \n  ⋅        ⋅    ⋅    ⋅         ⋅    ⋅   1.14815       ⋅    ⋅    ⋅    ⋅ \n  ⋅        ⋅    ⋅   0.490566   ⋅    ⋅   0.490566      ⋅    ⋅    ⋅    ⋅ \n  ⋅        ⋅    ⋅    ⋅         ⋅    ⋅    ⋅            ⋅    ⋅    ⋅   1.0\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.ispeer","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.ispeer","text":"ispeer(P::DEAPeers, i::Int64, j::Int64)\n\nReturn true if j is peer of decision making unit i.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> P = peers(dea(X, Y));\n\njulia> ispeer(P, 2, 4)\ntrue\n\n\n\n\n\nispeer(P::DEAPeers, i::String, j::String)\n\nReturn true if j is peer of decision making unit i.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> firms = [\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"; \"H\"; \"I\"; \"J\"; \"K\"]\n\njulia> P = peers(dea(X, Y, names = firms));\n\njulia> ispeer(P, \"B\", \"D\")\ntrue\n\n\n\n\n\nispeer(P::DEAPeersDMU, j::Int64)\n\nReturn true if j is peer.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> P = peers(dea(X, Y));\n\njulia> P2 = P[2];\n\njulia> ispeer(P2, 4)\ntrue\n\n\n\n\n\nispeer(P::DEAPeers, j::String)\n\nReturn true if j is peer.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> firms = [\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"; \"H\"; \"I\"; \"J\"; \"K\"]\n\njulia> P = peers(dea(X, Y, names = firms));\n\njulia> P2 = P[2]\n\njulia> ispeer(P2, \"D\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.multipliers","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.multipliers","text":"multipliers(model::AbstractTechnicalDEAModel, multiplier::Symbol)\n\nReturn multipliers (shadow prices) of a technical DEA model.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.rts","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.rts","text":"rts(model::AbstractTechnicalDEAModel)\n\nReturn the value measuring the returns to scale of a multiplier DEA model.\n\n\n\n\n\n","category":"function"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"optimizer/#Configuring-the-optimizer","page":"Configuring Optimizer","title":"Configuring the optimizer","text":"","category":"section"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"DataEnvelopmentAnalysis.jl will use a default optimizer/solver for each DEA model, as shown in the next table.","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"Function Specific Options Problem type Default Optimizer\ndea  LP GLPK\ndeabigdata  LP GLPK\ndeaddf  LP GLPK\ndeaadd  LP GLPK\ndeagdf  NLP Ipopt\ndearussell :Input or :Output LP GLPK\ndearussell :Graph NLP Ipopt\ndeaerg  LP GLPK\ndeamddf  LP GLPK\ndeaholder l = 1 LP GLPK\ndeaholder l = 2 QP \ndeaholder l = Inf LP GLPK\ndearddf :ERG LP GLPK\ndearddf :MDDF LP GLPK\ndeacost  LP GLPK\ndearevenue  LP GLPK\ndeaprofit  LP GLPK\ndeaprofitability  NLP Ipopt\nmalmquist  LP GLPK","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"Where:","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"LP = Linear programming.\nNLP = Nonlinear programming.\nQP = Quadratic programming.","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"Models can be solved using a different optimizer by passing a DEAOptimizer object to the optimizer optional argument. See JuMP documentation for a list of all available solvers.","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"warning: Choose a valid optimizer\nThe optimizer must support the problem type of the DEA model.For example, you cannot solve a Generalized Distance Function DEA model using the GLPK solver because it is a linear programming solver and deagdf requires a nonlinear programming solver.","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"The following is an example of solving the radial DEA model using the Ipopt sovler:","category":"page"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"julia> using Ipopt\n\njulia> using DataEnvelopmentAnalysis\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> myoptimizer = DEAOptimizer(Ipopt.Optimizer, time_limit = 10, silent = true);\n\njulia> dea(X, Y, slack = false, optimizer = myoptimizer)\nRadial DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = CRS\n──────────────\n    efficiency\n──────────────\n1     1.0\n2     0.62229\n3     0.819856\n4     1.0\n5     0.310371\n6     0.555555\n7     1.0\n8     0.757669\n9     0.820106\n10    0.490566\n11    1.0\n──────────────","category":"page"},{"location":"optimizer/#Optimizer-API","page":"Configuring Optimizer","title":"Optimizer API","text":"","category":"section"},{"location":"optimizer/","page":"Configuring Optimizer","title":"Configuring Optimizer","text":"DEAOptimizer\nnewdeamodel","category":"page"},{"location":"optimizer/#DataEnvelopmentAnalysis.DEAOptimizer","page":"Configuring Optimizer","title":"DataEnvelopmentAnalysis.DEAOptimizer","text":"DEAOptimizer(optimizer; time_limit, silent)\n\nAn data structure storing the configuration of a DEA optimizer.\n\nOptimizer specification:\n\nLP: linear programming default optimizer, GLPK.\nNLP: nonlinear programmin default optimizer, Ipopt.\nAny JuMP supported solver.\n\nOptional Arguments\n\ntime_limit=:60: time limit in seconds.\nsilent=:true: suppress optimizer output.\n\nExamples\n\njulia> myoptimizer = DEAOptimizer(GLPK.Optimizer, time_limit = 10, silent = true);\n\n\n\n\n\n","category":"type"},{"location":"optimizer/#DataEnvelopmentAnalysis.newdeamodel","page":"Configuring Optimizer","title":"DataEnvelopmentAnalysis.newdeamodel","text":"newdeamodel(DEAOptimizer)\n\nGenerate a new JuMP model for DEA with the specified optimizer.\n\nThis function is used internally and for packages that want to extend the functionality of this package.\n\nExamples\n\njulia> deamodel = newdeamodel(DEAOptimizer(GLPK.Optimizer));\n\n\n\n\n\n","category":"function"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"economic/revenue/#Revenue-Models","page":"Revenue Models","title":"Revenue Models","text":"","category":"section"},{"location":"economic/revenue/#Revenue-Efficiency-Model-with-Radial-Technical-Efficiency","page":"Revenue Models","title":"Revenue Efficiency Model with Radial Technical Efficiency","text":"","category":"section"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"Let us denote by Rleft(mathbfxmathbfpright) the maximum feasible revenue using inputs' levels mathbfx and given the outputs' prices mathbfp: Rleft(mathbfxmathbfpright)=max left sumlimits_i=1^sp_iy_i  mathbfx_o geqslant Xmathbflambdamathbfy leqslant Ymathbflambda mathbflambda  geqslant mathbf0 right; i.e.,  considering the output possibility set producible with mathbfx_o. In this case, we calculate maximum revenue along with the optimal output quantities mathbfy^*  by solving the following program:","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"beginaligned\n  undersetmathbfy mathbflambda mathopmax quad quad quad  Rleft(mathbfx_omathbfpright)=mathbfpy^*   \n  textsubject textto  \n  quad quad quad quad quad  mathbfx_oge Xmathbflambda   \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy  \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"The measurement of revenue efficiency assuming variable returns to scale, VRS, adds the following condition:","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"Revenue efficiency defines as the ratio of observed revenue to maximum revenue: RE=mathbfpy_oRleft(mathbfxmathbfpright)  Duality results presented in *Shephard (1953)* from an output perspective allow us to decompose RE into the output oriented technical efficiency measure and the residual difference corresponding to the allocative revenue efficiency. Allocative efficiency defines as the ratio of revenue at the technically efficient projection of the observation to maximum revenue.","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"In this example we compute the revnue efficiency measure under variable returns to scale:","category":"page"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"julia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\njulia> dearevenue(X, Y, P)\nRevenue DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nOrientation = Output; Returns to Scale = VRS\n──────────────────────────────────\n    Revenue  Technical  Allocative\n──────────────────────────────────\n1  0.644444   0.777778    0.828571\n2  1.0        1.0         1.0\n3  1.0        1.0         1.0\n4  0.5        0.5         1.0\n5  0.456522   0.6         0.76087\n──────────────────────────────────","category":"page"},{"location":"economic/revenue/#dearevenue-Function-Documentation","page":"Revenue Models","title":"dearevenue Function Documentation","text":"","category":"section"},{"location":"economic/revenue/","page":"Revenue Models","title":"Revenue Models","text":"dearevenue","category":"page"},{"location":"economic/revenue/#DataEnvelopmentAnalysis.dearevenue","page":"Revenue Models","title":"DataEnvelopmentAnalysis.dearevenue","text":"dearevenue(X, Y, P)\n\nCompute revenue efficiency using data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\njulia> dearevenue(X, Y, P)\nRevenue DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nOrientation = Output; Returns to Scale = VRS\n──────────────────────────────────\n    Revenue  Technical  Allocative\n──────────────────────────────────\n1  0.644444   0.777778    0.828571\n2  1.0        1.0         1.0\n3  1.0        1.0         1.0\n4  0.5        0.5         1.0\n5  0.456522   0.6         0.76087\n──────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\n    # Solve nonlinear problem to display Ipopt initial message\n    deamddf([1; 2; 3], [1; 1; 1],Gx = :Ones, Gy = :Ones, rts = :VRS, slack = false)\nend","category":"page"},{"location":"technical/modifiedddf/#Modified-Directional-Distance-Function","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"","category":"section"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"Based on the data  matrix (XY), we calculate the modified directional distance function MDDF, (Aparicio et al. 2013), of each observation o by solving n times the following linear programming problem:","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"beginaligned\n   undersetbeta^x beta^ylambda_j mathopmin quad quad quad  beta^x + beta^y   \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le x_io - beta^x g_io^- qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge y_ro + beta^y g_ro^+ qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n  \n   quad quad quad quad quad  beta^x ge 0 qquad i = 1m  \n   quad quad quad quad quad  beta^y ge 0 qquad r = 1s  \nendaligned","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"with the following condition when assuming variable returns to scale:","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"In this example we compute the modified directional distance function model under variable returns to scale using ones as directions for both inputs and outputs::","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"julia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> deamddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS)\nModified DDF DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nReturns to Scale = VRS\nGx = Ones; Gy = Ones\n───────────────────────────────────────────────\n   efficiency       βx     βy  slackX1  slackY1\n───────────────────────────────────────────────\n1     0.0      0.0      0.0        0.0      0.0\n2     0.0      0.0      0.0        0.0      0.0\n3     0.0      0.0      0.0        0.0      0.0\n4     0.0      0.0      0.0        0.0      0.0\n5     4.0      2.0      2.0        0.0      0.0\n6     7.33333  7.33333  0.0        0.0      0.0\n7     2.0      2.0      0.0        0.0      0.0\n8     8.059    5.412    2.647      0.0      0.0\n───────────────────────────────────────────────","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"julia> deamddfvrs= deamddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS);\n\njulia> efficiency(deamddfvrs)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 4.000000000000001\n 7.333333333333334\n 2.0\n 8.059000000000001","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"Estimated beta on inputs and outputs are returned with the efficiency function:","category":"page"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"julia> efficiency(deamddfvrs, :X)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 1.999999999999999\n 7.333333333333334\n 2.0\n 5.412000000000001\n\njulia> efficiency(deamddfvrs, :Y)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 2.0000000000000018\n 0.0\n 0.0\n 2.6470000000000002","category":"page"},{"location":"technical/modifiedddf/#deamddf-Function-Documentation","page":"Modified Directional Distance Function","title":"deamddf Function Documentation","text":"","category":"section"},{"location":"technical/modifiedddf/","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"deamddf","category":"page"},{"location":"technical/modifiedddf/#DataEnvelopmentAnalysis.deamddf","page":"Modified Directional Distance Function","title":"DataEnvelopmentAnalysis.deamddf","text":"deamddf(X, Y; Gx, Gy)\n\nCompute data envelopment analysis modified directional distance function model for inputs X and outputs Y, using directions Gx and Gy.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353] ;\n\njulia> deamddf(X, Y, Gx = :Ones, Gy = :Ones)\nModified DDF DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nReturns to Scale = CRS\nGx = Ones; Gy = Ones\n────────────────────────────────────────────\n   efficiency   βx      βy  slackX1  slackY1\n────────────────────────────────────────────\n1       1.5    0.0   1.5        0.0      0.0\n2       0.0    0.0   0.0        0.0      0.0\n3       2.0    0.0   2.0        0.0      0.0\n4       6.0    0.0   6.0        0.0      0.0\n5       4.5    0.0   4.5        0.0      0.0\n6      10.5    0.0  10.5        0.0      0.0\n7       8.5    0.0   8.5        0.0      0.0\n8       9.412  0.0   9.412      0.0      0.0\n────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"productivity/commonproductivity/","page":"Common functions for productivity change models","title":"Common functions for productivity change models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"productivity/commonproductivity/#Common-functions-for-productivity-change-models","page":"Common functions for productivity change models","title":"Common functions for productivity change models","text":"","category":"section"},{"location":"productivity/commonproductivity/","page":"Common functions for productivity change models","title":"Common functions for productivity change models","text":"nperiods\nprodchange","category":"page"},{"location":"productivity/commonproductivity/#DataEnvelopmentAnalysis.nperiods","page":"Common functions for productivity change models","title":"DataEnvelopmentAnalysis.nperiods","text":"nperiods(model::AbstractProductivityDEAModel)\n\nReturn number of time periods of a productivity DEA model.\n\nExamples\n\njulia> X = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> X[:, :, 1] = [2; 3; 5; 4; 4];\n\njulia> X[:, :, 2] = [1; 2; 4; 3; 4];\n\njulia> Y = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> Y[:, :, 1] = [1; 4; 6; 3; 5];\n\njulia> Y[:, :, 2] = [1; 4; 6; 3; 3];\n\njulia> mprod = malmquist(X, Y);\n\njulia> nperiods(mprod)\n2\n\n\n\n\n\n","category":"function"},{"location":"productivity/commonproductivity/#DataEnvelopmentAnalysis.prodchange","page":"Common functions for productivity change models","title":"DataEnvelopmentAnalysis.prodchange","text":"prodchange(model::AbstractProductivityDEAModel)\n\nReturn productivity change of a productivity change DEA model.\n\nOptional Arguments\n\ntype=Prod: component of productivity change to return.\n\nType specification:\n\n:Prod: productivity change.\n:EC: efficiency change.\n:TC: technological change.\n\nExamples\n\njulia> X = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> X[:, :, 1] = [2; 3; 5; 4; 4];\n\njulia> X[:, :, 2] = [1; 2; 4; 3; 4];\n\njulia> Y = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> Y[:, :, 1] = [1; 4; 6; 3; 5];\n\njulia> Y[:, :, 2] = [1; 4; 6; 3; 3];\n\njulia> mprod = malmquist(X, Y);\n\njulia> prodchange(mprod)\n×1 Matrix{Float64}:\n 2.0\n 1.5\n 1.25\n 1.3333333333333333\n 0.6000000000000001\n\njulia> prodchange(mprod, :EC)\n5×1 Matrix{Float64}:\n 1.3333333333333333\n 1.0\n 0.8333333333333334\n 0.8888888888888888\n 0.4\n\njulia> prodchange(mprod, :TC)\n5×1 Matrix{Float64}:\n 1.5\n 1.5\n 1.5\n 1.5\n 1.5\n\n\n\n\n\n","category":"function"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"productivity/malmquist/#The-Malmquist-index","page":"Malmquist Index","title":"The Malmquist index","text":"","category":"section"},{"location":"productivity/malmquist/#The-Malmquist-Productivity-Index","page":"Malmquist Index","title":"The Malmquist Productivity Index","text":"","category":"section"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"The Malmquist index introduced by Caves, Christensen and Diewert(1982) measures the change in  productivity of the observation under evaluation by comparing its relative performance with respect to  reference  technologies corresponding to two different time periods.","category":"page"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"Following Fare, Grosskopf, Norris and Zhang (1994) productivity change can be decomposed into efficiency change and technical change under the assumption of a constant returns to scale techncology.","category":"page"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"In this example we compute the Malmquist productivity index:","category":"page"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"julia> X = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> X[:, :, 1] = [2; 3; 5; 4; 4];\n\njulia> X[:, :, 2] = [1; 2; 4; 3; 4];\n\njulia> Y = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> Y[:, :, 1] = [1; 4; 6; 3; 5];\n\njulia> Y[:, :, 2] = [1; 4; 6; 3; 3];\n\njulia> malmquist(X, Y)\nMamlmquist DEA Model \nDMUs = 5; Inputs = 1; Outputs = 1; Time periods = 2\nOrientation = Input; Returns to Scale = CRS\nReferene period = Geomean\n─────────────────────────\n         M        EC   TC\n─────────────────────────\n1  2.0      1.33333   1.5\n2  1.5      1.0       1.5\n3  1.25     0.833333  1.5\n4  1.33333  0.888889  1.5\n5  0.6      0.4       1.5\n─────────────────────────\nM  = Malmquist Productivity Index \nEC = Efficiency Change \nTC = Technological Change","category":"page"},{"location":"productivity/malmquist/#malmquist-Function-Documentation","page":"Malmquist Index","title":"malmquist Function Documentation","text":"","category":"section"},{"location":"productivity/malmquist/","page":"Malmquist Index","title":"Malmquist Index","text":"malmquist","category":"page"},{"location":"productivity/malmquist/#DataEnvelopmentAnalysis.malmquist","page":"Malmquist Index","title":"DataEnvelopmentAnalysis.malmquist","text":"malmquist(X, Y)\n\nCompute the Malmquist productivity index using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses between input oriented radial model :Input or output oriented radial model :Output.\nrefperiod=:Geomean: chooses reference period for technological change: :Base, :Comparison or :Geomean.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> X[:, :, 1] = [2; 3; 5; 4; 4];\n\njulia> X[:, :, 2] = [1; 2; 4; 3; 4];\n\njulia> Y = Array{Float64,3}(undef, 5, 1, 2);\n\njulia> Y[:, :, 1] = [1; 4; 6; 3; 5];\n\njulia> Y[:, :, 2] = [1; 4; 6; 3; 3];\n\njulia> malmquist(X, Y)\nMamlmquist DEA Model \nDMUs = 5; Inputs = 1; Outputs = 1; Time periods = 2\nOrientation = Input; Returns to Scale = CRS\nReferene period = Geomean\n─────────────────────────\n         M        EC   TC\n─────────────────────────\n1  2.0      1.33333   1.5\n2  1.5      1.0       1.5\n3  1.25     0.833333  1.5\n4  1.33333  0.888889  1.5\n5  0.6      0.4       1.5\n─────────────────────────\nM  = Malmquist Productivity Index \nEC = Efficiency Change \nTC = Technological Change\n\n\n\n\n\n","category":"function"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/directional/#Directional-Distance-Function-Models","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"","category":"section"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"Chambers, Chung and Fare (1996) introduced a measure of efficiency that projects observation left( mathbfx_omathbfy_o right) in a pre-assigned  direction  mathbfg= left(-mathbfg_x^-mathbfg^+_y right)neqmathbf0_m+s, mathbfg^-_xmathbbin R^m and  mathbfg^+_ymathbbin R^s, in a proportion beta. The associated linear program is:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"beginaligned\n  undersetbeta mathbflambda mathopmax quad quad quad quad beta  \n  textsubject textto \n  quad quad quad quad quad  Xlambdale mathbfx_o -betamathbfg^-_x \n  quad quad quad quad quad   Ymathbflambda ge mathbfy_o+beta mathbfg^+_y  \n  quad quad quad quad quad  mathbflambda ge mathbf0   quad \nendaligned","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"The measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"In this example we compute the directional distance function DEA model under constant returns to scale using ones as directions for both inputs and outputs:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"julia> using DataEnvelopmentAnalysis\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaddf(X, Y, Gx = :Ones, Gy = :Ones)\nDirectional DF DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nReturns to Scale = CRS\nGx = Ones; Gy = Ones\n─────────────────────────────────────────────────────\n      efficiency       slackX1       slackX2  slackY1\n─────────────────────────────────────────────────────\n1   -3.43053e-16   0.0           0.0              0.0\n2    3.21996      -3.21359e-15   0.0              0.0\n3    2.12169       0.0          -4.80367e-15      0.0\n4    0.0          -8.03397e-16   0.0              0.0\n5    6.73567      -2.41019e-15   0.0              0.0\n6    1.94595      10.9189        0.0              0.0\n7    0.0           0.0           0.0              0.0\n8    3.63586       6.42718e-15   0.0              0.0\n9    1.83784       4.75676       0.0              0.0\n10  10.2311        6.12173e-15   0.0              0.0\n11   0.0           0.0           4.0              0.0\n─────────────────────────────────────────────────────","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"To compute the variable returns to scale model, we simply set the rts parameter to :VRS:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"julia> deaddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS)\nDirectional DF DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nReturns to Scale = VRS\nGx = Ones; Gy = Ones\n────────────────────────────────────────────────────\n      efficiency       slackX1  slackX2      slackY1\n────────────────────────────────────────────────────\n1   -3.43053e-16   0.0              0.0  0.0\n2    1.41887       0.0              0.0  7.41268e-15\n3    0.0           0.0              0.0  0.0\n4    0.0          -8.03397e-16      0.0  0.0\n5    4.06792       0.0              0.0  0.0\n6   -1.81673e-16   2.70127e-16      0.0  3.78178e-16\n7    0.0           0.0              0.0  0.0\n8    0.0           0.0              0.0  0.0\n9    0.0           0.0              0.0  0.0\n10   5.0           0.0              6.0  0.0\n11   0.0           0.0              4.0  4.78849e-16\n────────────────────────────────────────────────────","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"julia> deaddfvrs = deaddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS);\n\njulia> efficiency(deaddfvrs)\n11-element Vector{Float64}:\n -3.4305304041327586e-16\n  1.4188679245283022\n  0.0\n  0.0\n  4.067924528301886\n -1.816728585750256e-16\n  0.0\n  0.0\n  0.0\n  5.000000000000003\n  0.0","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"The optimal peers, λ, are returned with the peers function and are returned as a DEAPeers object:","category":"page"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"julia> peers(deaddfvrs)\nDEA Peers\n1: 1 ( 1.0 ) \n2: 1 ( 0.4981132075471699 ) 6 ( 0.22830188679245278 ) 7 ( 0.2735849056603774 ) \n3: 3 ( 1.0 ) \n4: 4 ( 1.0 ) \n5: 1 ( 0.5132075471698113 ) 6 ( 0.4018867924528304 ) 7 ( 0.08490566037735842 ) \n6: 6 ( 1.0 ) \n7: 7 ( 1.0 ) \n8: 8 ( 1.0 ) \n9: 9 ( 1.0 ) \n10: 9 ( 1.0000000000000002 ) \n11: 1 ( 1.0 ) ","category":"page"},{"location":"technical/directional/#deaddf-Function-Documentation","page":"Directional Distance Function Models","title":"deaddf Function Documentation","text":"","category":"section"},{"location":"technical/directional/","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"deaddf","category":"page"},{"location":"technical/directional/#DataEnvelopmentAnalysis.deaddf","page":"Directional Distance Function Models","title":"DataEnvelopmentAnalysis.deaddf","text":"deaddf(X, Y; Gx, Gy)\n\nCompute data envelopment analysis directional distance function model for inputs X and outputs Y, using directions Gx and Gy.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaddf(X, Y, Gx = :Ones, Gy = :Ones)\nDirectional DF DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nReturns to Scale = CRS\nGx = Ones; Gy = Ones\n─────────────────────────────────────────────────────\n      efficiency       slackX1       slackX2  slackY1\n─────────────────────────────────────────────────────\n1   -3.43053e-16   0.0           0.0              0.0\n2    3.21996      -3.21359e-15   0.0              0.0\n3    2.12169       0.0          -4.80367e-15      0.0\n4    0.0          -8.03397e-16   0.0              0.0\n5    6.73567      -2.41019e-15   0.0              0.0\n6    1.94595      10.9189        0.0              0.0\n7    0.0           0.0           0.0              0.0\n8    3.63586       6.42718e-15   0.0              0.0\n9    1.83784       4.75676       0.0              0.0\n10  10.2311        6.12173e-15   0.0              0.0\n11   0.0           0.0           4.0              0.0\n─────────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"economic/commoneconomic/","page":"Common functions for economic models","title":"Common functions for economic models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"economic/commoneconomic/#Common-functions-for-economic-models","page":"Common functions for economic models","title":"Common functions for economic models","text":"","category":"section"},{"location":"economic/commoneconomic/","page":"Common functions for economic models","title":"Common functions for economic models","text":"efficiency(::AbstractEconomicDEAModel, ::Symbol)\ntargets(::AbstractEconomicDEAModel, ::Symbol)\nnormfactor\nismonetary(::AbstractEconomicDEAModel)","category":"page"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.efficiency-Tuple{AbstractEconomicDEAModel, Symbol}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.efficiency","text":"efficiency(model::AbstractEconomicDEAModel)\n\nReturn efficiency scores of an economic DEA model.\n\nOptional Arguments\n\ntype=Economic: type of efficiency scores to return.\n\nType specification:\n\n:Economic: returns economic efficiency of the model.\n:Technical: returns technical efficiency.\n:Allocative: returns allocative efficiency.\n\nSome models also allow these types:\n\n:CRS: returns technical efficiency under constant returns to scale.\n:VRS: returns technical efficiency under variable returns to scale.\n:Scale: returns scale efficiency.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\njulia> profitbl = deaprofitability(X, Y, W, P)\njulia> efficiency(profitbl)\n5-element Vector{Float64}:\n 0.38795983677810825\n 0.9999999082180037\n 0.7652173234322985\n 0.24999998462128403\n 0.15879016408241559\n\njulia> efficiency(profitbl, :Allocative)\n5-element Vector{Float64}:\n 0.6096511887087086\n 0.9999999387832732\n 0.765217344390068\n 0.9999999256504392\n 0.608695614904087\n\n\n\n\n\n","category":"method"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.targets-Tuple{AbstractEconomicDEAModel, Symbol}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.targets","text":"targets(model::AbstractEconomicDEAModel, target::Symbol)\n\nReturn targets of an economic DEA model.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\njulia> profit = deaprofit(X, Y, W, P, Gx = :Monetary, Gy = :Monetary);\njulia> targets(profit, :X)\n5×2 Matrix{Float64}:\n 2.0  4.0\n 2.0  4.0\n 2.0  4.0\n 2.0  4.0\n 2.0  4.0\n\njulia> targets(profit, :Y)\n5×2 Matrix{Float64}:\n 10.0  8.0\n 10.0  8.0\n 10.0  8.0\n 10.0  8.0\n 10.0  8.0\n\n\n\n\n\n\n","category":"method"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.normfactor","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.normfactor","text":"normfactor(model::AbstractEconomicDEAModel)\n\nReturn the normalization factor of an economic DEA model.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\njulia> profit = deaprofit(X, Y, W, P, Gx = :Ones, Gy = :Ones)\njulia> normfactor(profit)\n5-element Vector{Float64}:\n 8.0\n 8.0\n 8.0\n 8.0\n 8.0\n\n\n\n\n\n","category":"function"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.ismonetary-Tuple{AbstractEconomicDEAModel}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.ismonetary","text":"ismonetary(model::AbstractEconomicDEAModel)\n\nIndicate whether inefficiency is in monetary units.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\njulia> P = [3 2; 3 2; 3 2; 3 2; 3 2.0];\njulia> profit = deaprofit(X, Y, W, P, Gx = :Ones, Gy = :Ones, monetary = true);\njulia> ismonetary(profit)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/additive/#Additive-Models","page":"Additive Models","title":"Additive Models","text":"","category":"section"},{"location":"technical/additive/#Weighted-Additive-Model","page":"Additive Models","title":"Weighted Additive Model","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The additive model measures technical efficiency based solely on input excesses and output shortfalls, and characterizes efficiency in terms of the input and output slacks: mathbfs^-mathbbin R^m and mathbfs^+mathbbin R^s, respectively. . The package implements the weighted additive formulation of Cooper and Pastor (1995) and Pastor, Lovell and Aparicio (2011), whose associated linear program is:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"beginaligned\n   undersetmathbflambda mathbfs^-mathbfs^+mathopmax quad quad quad quad omega =mathbfrho_x^-mathbfs^mathbf-+mathbfrho_y^+mathbfs^+ \n  textsubject textto \n  quad quad quad quad quad quad Xmathbflambda +mathbfs^mathbf-=  mathbfx_o \n  quad quad quad quad quad quad Ymathbflambda -mathbfs^+= mathbfy_o \n  quad quad quad quad quad quad mathbfelambda=1 \n  quad quad quad quad quad quad mathbflambda ge mathbf0 mathbfs^mathbf-ge 0mathbfs^+ge 0 \nendaligned","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"where (mathbfrho_x^- mathbfrho_y^+) mathbbin R^m_+times mathbbR_+^s are the inputs and outputs weight vectors whose elements can vary across DMUs.","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"In this example we compute the additive DEA model with all weights equal to one:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"julia> using DataEnvelopmentAnalysis\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaadd(X, Y)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = Ones\n────────────────────────────────────────────────────\n      efficiency       slackX1  slackX2      slackY1\n────────────────────────────────────────────────────\n1    0.0           0.0              0.0  0.0\n2    7.33333       4.33333          0.0  3.0\n3    0.0           0.0              0.0  0.0\n4   -8.03397e-16  -8.03397e-16      0.0  0.0\n5   18.0          13.0              1.0  4.0\n6    6.48305e-16   2.70127e-16      0.0  3.78178e-16\n7    0.0           0.0              0.0  0.0\n8    0.0           0.0              0.0  0.0\n9    0.0           0.0              0.0  0.0\n10  35.0          25.0             10.0  0.0\n11   4.0           0.0              4.0  4.78849e-16\n────────────────────────────────────────────────────","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The same model is computed with:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"deaadd(X, Y, :Ones)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The additive DEA model can be computed under constant returns to scale setting the rts parameter to :CRS:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"deaadd(X, Y, :Ones, rts = :CRS)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The package can compute a wide class of different DEA models known as general  efficiency measures (GEMs):","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The measure of inefficiency proportions (MIP).\nThe normalized weighted additive DEA model.\nThe range adjusted measure (RAM).\nThe bounded adjusted  measure (BAM).","category":"page"},{"location":"technical/additive/#Measure-of-Inefficiency-Proportions-(MIP)","page":"Additive Models","title":"Measure of Inefficiency Proportions (MIP)","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The measure of inefficiency proportions (MIP), Charnes et al. (1987) and Cooper et al. (1999), use the weights:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"(mathbfrho_x^- mathbfrho_y^+)=(1mathbfx_o1mathbfy_o)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"julia> deaadd(X, Y, :MIP)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = MIP\n─────────────────────────────────────────────────────\n      efficiency       slackX1  slackX2       slackY1\n─────────────────────────────────────────────────────\n1    0.0           0.0              0.0   0.0\n2    0.507519      0.0              0.0   7.10526\n3    0.0           0.0              0.0   0.0\n4   -4.72586e-17  -8.03397e-16      0.0   0.0\n5    2.20395       0.0              0.0  17.6316\n6    1.31279e-16   8.10382e-16      0.0   8.64407e-16\n7    0.0           0.0              0.0   0.0\n8    0.0           0.0              0.0   0.0\n9    0.0           0.0              0.0   0.0\n10   1.04322      17.0             15.0   1.0\n11   0.235294      0.0              4.0   0.0\n─────────────────────────────────────────────────────","category":"page"},{"location":"technical/additive/#Normalized-Weighted-Additive-Model","page":"Additive Models","title":"Normalized Weighted Additive Model","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The normalized weighted additive DEA model, Lovell and Pastor (1995), use the weights:","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"(mathbfrho_x^- mathbfrho_y^+)=(1mathbfσ^-1mathbfσ^+)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"where mathbfσ^-and mathbfσ^+ are the standard deviations of inputs and outputs respectively.","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"julia> deaadd(X, Y, :Normalized)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = Normalized\n──────────────────────────────────────────────────────────\n      efficiency       slackX1       slackX2       slackY1\n──────────────────────────────────────────────────────────\n1    0.0           0.0           0.0           0.0\n2    0.804925      0.0           0.65          6.25\n3    0.0           0.0           0.0           0.0\n4   -9.79609e-17   0.0          -6.09909e-16   0.0\n5    2.01497       0.0           2.95         13.75\n6    4.81529e-16   2.49057e-15   0.0           2.37658e-15\n7    0.0           0.0           0.0           0.0\n8    0.0           0.0           0.0           0.0\n9    0.0           0.0           0.0           0.0\n10   3.98989      17.0          15.0           1.0\n11   0.642462      0.0           4.0           0.0\n──────────────────────────────────────────────────────────","category":"page"},{"location":"technical/additive/#Range-Adjusted-Measure-(RAM)","page":"Additive Models","title":"Range Adjusted Measure (RAM)","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The range adjusted measure (RAM), Cooper et al. (1999), use the weights::","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"(mathbfrho^- mathbfrho^+)=(1(m+s)R^-(1(m+s)R^+)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"where R^-and R^+are the inputs and outputs variables' ranges.","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"julia> deaadd(X, Y, :RAM)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = RAM\n──────────────────────────────────────────────────────────\n      efficiency       slackX1       slackX2       slackY1\n──────────────────────────────────────────────────────────\n1    0.0           0.0           0.0           0.0\n2    0.102975      0.0           0.0           7.10526\n3    0.0           0.0           0.0           0.0\n4   -1.01651e-17   0.0          -6.09909e-16   0.0\n5    0.25553       0.0           0.0          17.6316\n6    5.68808e-17   2.49057e-15   0.0           2.37658e-15\n7    0.0           0.0           0.0           0.0\n8    0.0           0.0           0.0           0.0\n9    0.0           0.0           0.0           0.0\n10   0.417646     17.0          15.0           1.0\n11   0.0666667     0.0           4.0           0.0\n──────────────────────────────────────────────────────────","category":"page"},{"location":"technical/additive/#Bounded-Adjusted-Measure-(BAM)","page":"Additive Models","title":"Bounded Adjusted  Measure (BAM)","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"The bounded adjusted  measure (BAM), Cooper et al. (2011), use the weights:::","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"(mathbfrho_x^- mathbfrho_y^+)=(1(m+s)(mathbfx_o-mathbfunderlinex)(1(m+s)(mathbfoverliney - mathbfy_o)","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"where mathbfunderlinex and mathbfoverliney are the minimum and maximum observed values of inputs and outputs respectively.","category":"page"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"julia> deaadd(X, Y, :BAM)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = BAM\n─────────────────────────────────────────────────\n      efficiency   slackX1  slackX2       slackY1\n─────────────────────────────────────────────────\n1    0.0           0.0          0.0   0.0\n2    0.199894      6.59649      0.0   0.0\n3    0.0           0.0          0.0   0.0\n4   -3.78838e-17   0.0          0.0  -5.68256e-16\n5    0.432971     13.0          1.0   4.0\n6    1.11554e-17   0.0          0.0   7.36254e-16\n7    0.0           0.0          0.0   0.0\n8    0.0           0.0          0.0   0.0\n9    0.0           0.0          0.0   0.0\n10   0.571361      5.0         11.0   5.0\n11   0.121212      0.0          4.0   0.0\n─────────────────────────────────────────────────","category":"page"},{"location":"technical/additive/#deaadd-Function-Documentation","page":"Additive Models","title":"deaadd Function Documentation","text":"","category":"section"},{"location":"technical/additive/","page":"Additive Models","title":"Additive Models","text":"deaadd","category":"page"},{"location":"technical/additive/#DataEnvelopmentAnalysis.deaadd","page":"Additive Models","title":"DataEnvelopmentAnalysis.deaadd","text":"deaadd(X, Y, model)\n\nCompute related data envelopment analysis weighted additive models for inputs X and outputs Y.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\norient=:Graph: choose between graph oriented :Graph, input oriented :Input, or output oriented model :Output.\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\nrhoX: matrix of weights of inputs. Only if model=:Custom.\nrhoY: matrix of weights of outputs. Only if model=:Custom.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\ndisposX=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\ndisposY=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> deaadd(X, Y, :MIP)\nWeighted Additive DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nWeights = MIP\n─────────────────────────────────────────────────────\n      efficiency       slackX1  slackX2       slackY1\n─────────────────────────────────────────────────────\n1    0.0           0.0              0.0   0.0\n2    0.507519      0.0              0.0   7.10526\n3    0.0           0.0              0.0   0.0\n4   -4.72586e-17  -8.03397e-16      0.0   0.0\n5    2.20395       0.0              0.0  17.6316\n6    1.31279e-16   8.10382e-16      0.0   8.64407e-16\n7    0.0           0.0              0.0   0.0\n8    0.0           0.0              0.0   0.0\n9    0.0           0.0              0.0   0.0\n10   1.04322      17.0             15.0   1.0\n11   0.235294      0.0              4.0   0.0\n─────────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/radial/#Radial-Models","page":"Radial Models","title":"Radial Models","text":"","category":"section"},{"location":"technical/radial/#Radial-Input-Oriented-Model","page":"Radial Models","title":"Radial Input Oriented Model","text":"","category":"section"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"Based on the data  matrix (XY), we calculate the input oriented efficiency of each observation o by solving n times the following linear programming problem – known as the Charnes, Cooper, and Rhodes (1978), CCR, model:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"beginaligned\n   undersettheta mathbflambda mathopmin quad quad quad  theta  \n   textsubject textto  \n   quad quad quad quad quad  Xmathbflambda  le theta mathbfx_o \n   quad quad quad quad quad  Ymathbflambda  ge mathbfy_o  \n   quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"The measurement of technical efficiency assuming variable returns to scale, VRS, as introduced by Banker, Charnes and Cooper (1984) – known as the Banker, Charnes and Cooper, BCC, model – adds the following condition:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"In this example we compute the radial input oriented DEA model under constant returns to scale:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> using DataEnvelopmentAnalysis\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> dea(X, Y, orient = :Input, rts = :CRS)\nRadial DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = CRS\n──────────────────────────────────────────────────\n    efficiency       slackX1      slackX2  slackY1\n──────────────────────────────────────────────────\n1     1.0        0.0          0.0              0.0\n2     0.62229   -4.41868e-15  0.0              0.0\n3     0.819856   0.0          8.17926e-15      0.0\n4     1.0       -8.03397e-16  0.0              0.0\n5     0.310371   1.80764e-15  0.0              0.0\n6     0.555556   4.44444      0.0              0.0\n7     1.0        0.0          0.0              0.0\n8     0.757669   1.60679e-15  0.0              0.0\n9     0.820106   1.64021      0.0              0.0\n10    0.490566   9.68683e-15  0.0              0.0\n11    1.0        0.0          4.0              0.0\n──────────────────────────────────────────────────","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"To compute the variable returns to scale model, we simply set the rts parameter to :VRS:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> dea(X, Y, orient = :Input, rts = :VRS)\nRadial DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = VRS\n───────────────────────────────────────────────────────\n    efficiency       slackX1       slackX2      slackY1\n───────────────────────────────────────────────────────\n1     1.0        0.0           0.0          0.0\n2     0.869986   0.0           0.0          0.0\n3     1.0        0.0           2.56789e-13  0.0\n4     1.0       -8.03397e-16   0.0          0.0\n5     0.71164    0.0           0.0          2.69841\n6     1.0        2.70127e-16   0.0          3.78178e-16\n7     1.0        0.0           0.0          0.0\n8     1.0        0.0          -1.27018e-14  0.0\n9     1.0        0.0           0.0          0.0\n10    0.493121   3.90444e-15   0.0          0.0\n11    1.0        0.0           4.0          4.78849e-16\n───────────────────────────────────────────────────────","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> deaiovrs = dea(X, Y, orient = :Input, rts = :VRS);\n\njulia> efficiency(deaiovrs)\n11-element Vector{Float64}:\n 1.0\n 0.8699861687413553\n 1.0000000000000002\n 1.0\n 0.7116402116402116\n 1.0\n 1.0\n 0.9999999999999999\n 1.0\n 0.4931209268645909\n 1.0","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"The optimal peers, λ, are returned with the peers function and are returned as a DEAPeers object:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> peers(deaiovrs)\nDEA Peers\n1: 1 ( 1.0 ) \n2: 1 ( 0.5255878284923927 ) 6 ( 0.2842323651452281 ) 7 ( 0.1901798063623792 ) \n3: 3 ( 1.0000000000000002 ) \n4: 4 ( 1.0 ) \n5: 1 ( 0.5661375661375662 ) 6 ( 0.4338624338624339 ) \n6: 6 ( 1.0 ) \n7: 7 ( 1.0 ) \n8: 8 ( 0.9999999999999999 ) \n9: 9 ( 1.0 ) \n10: 1 ( 0.03711078928312814 ) 4 ( 0.4433381607530775 ) 7 ( 0.5195510499637944 ) \n11: 11 ( 1.0 ) ","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"Input and output slacks are returned with the slacks function:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> slacks(deaiovrs, :X)\n11×2 Matrix{Float64}:\n  0.0           0.0\n  0.0           0.0\n  0.0           2.56789e-13\n -8.03397e-16   0.0\n  0.0           0.0\n  2.70127e-16   0.0\n  0.0           0.0\n  0.0          -1.27018e-14\n  0.0           0.0\n  3.90444e-15   0.0\n  0.0           4.0","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> slacks(deaiovrs, :Y)\n11×1 Matrix{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 2.6984126984126924\n 3.7817815923971297e-16\n 0.0\n 0.0\n 0.0\n 0.0\n 4.788485288453362e-16","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"Input and output optimal targets are returned with the targets function:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> targets(deaiovrs, :X)\n11×2 Matrix{Float64}:\n  5.0     13.0\n 13.9198  10.4398\n 16.0     26.0\n 17.0     15.0\n 12.8095   9.96296\n 23.0      6.0\n 25.0     10.0\n 27.0     22.0\n 37.0     14.0\n 20.7111  12.328\n  5.0     13.0","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> targets(deaiovrs, :Y)\n11×1 Matrix{Float64}:\n 12.0\n 14.0\n 25.0\n 26.0\n 10.698412698412692\n  9.0\n 27.0\n 30.0\n 31.0\n 26.0\n 12.0","category":"page"},{"location":"technical/radial/#Radial-Output-Oriented-Model","page":"Radial Models","title":"Radial Output Oriented Model","text":"","category":"section"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"It is possible to calculate the output oriented technical efficiency of each observation by solving the following linear program:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"beginaligned\n  undersetphi mathbflambda mathopmax quad quad quad quad phi  \n  textsubject textto \n  quad quad quad quad quad  Xlambdale mathbfx_o \n  quad quad quad quad quad  Ymathbflambda  ge phi mathbfy_o \n  quad quad quad quad quad  mathbflambda ge mathbf0   quad \nendaligned","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"with the following condition when assuming variable returns to scale:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"In this example we compute the radial output oriented DEA model under variable returns to scale:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> dea(X, Y, orient = :Output, rts = :VRS)\nRadial DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Output; Returns to Scale = VRS\n──────────────────────────────────────────────────\n    efficiency       slackX1  slackX2      slackY1\n──────────────────────────────────────────────────\n1      1.0       0.0              0.0  0.0\n2      1.50752   5.78599e-15      0.0  0.0\n3      1.0       0.0              0.0  0.0\n4      1.0      -8.03397e-16      0.0  0.0\n5      3.20395  -3.38377e-15      0.0  0.0\n6      1.0       2.70127e-16      0.0  3.78178e-16\n7      1.0       0.0              0.0  0.0\n8      1.0       0.0              0.0  0.0\n9      1.0       0.0              0.0  0.0\n10     1.19231   5.0             11.0  0.0\n11     1.0       0.0              4.0  4.78849e-16\n──────────────────────────────────────────────────","category":"page"},{"location":"technical/radial/#Radial-Model-in-Multiplier-Form","page":"Radial Models","title":"Radial Model in Multiplier Form","text":"","category":"section"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"The dual to the input oriented and output oriented radial DEA models in envelopment form presented above is the multiplier form.","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"This example computes the radial input-oriented DEA model in multiplier form under constant returns to scale:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> deaiovrsm = deam(X, Y, rts = :VRS)\nRadial DEA Model (Multiplier form)\nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = VRS\n─────────────────────────────────────────────────\n    efficiency         v1           v2         u1\n─────────────────────────────────────────────────\n1     1.0       0.0901826  0.0422374    0.0833333\n2     0.869986  0.0197095  0.0570539    0.0148686\n3     1.0       0.0612245  0.000784929  0.0525903\n4     1.0       0.0416228  0.0194942    0.0384615\n5     0.71164   0.0185185  0.047619     0.0\n6     1.0       0.0        0.166667     0.037037\n7     1.0       0.0261969  0.0345077    0.037037\n8     1.0       0.0227671  0.0175131    0.0875657\n9     1.0       0.0        0.0714286    0.0714286\n10    0.493121  0.013034   0.0181028    0.0137581\n11    1.0       0.2        2.61229e-17  0.0833333\n─────────────────────────────────────────────────","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"Input and output virtual multipliers (shadow prices) are returned with the multipliers function:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> multipliers(deaiovrsm, :X)\n11×2 Matrix{Float64}:\n 0.0901826  0.0422374\n 0.0197095  0.0570539\n 0.0612245  0.000784929\n 0.0416228  0.0194942\n 0.0185185  0.047619\n 0.0        0.166667\n 0.0261969  0.0345077\n 0.0227671  0.0175131\n 0.0        0.0714286\n 0.013034   0.0181028\n 0.2        2.61229e-17","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> multipliers(deaiovrsm, :Y)\n11×1 Matrix{Float64}:\n 0.08333333333333336\n 0.014868603042876911\n 0.05259026687598115\n 0.038461538461538464\n 0.0\n 0.03703703703703698\n 0.03703703703703704\n 0.08756567425569173\n 0.07142857142857138\n 0.013758146270818254\n 0.0833333333333333","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"The value measuring the returns to scale is returned with the rts function:","category":"page"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"julia> rts(deaiovrsm)\n11-element Vector{Float64}:\n  0.0\n  0.6618257261410788\n -0.3147566718995288\n  0.0\n  0.7116402116402116\n  0.6666666666666667\n  0.0\n -1.6269702276707518\n -1.2142857142857133\n  0.13540912382331627\n  0.0","category":"page"},{"location":"technical/radial/#dea-Function-Documentation","page":"Radial Models","title":"dea Function Documentation","text":"","category":"section"},{"location":"technical/radial/","page":"Radial Models","title":"Radial Models","text":"dea\ndeam","category":"page"},{"location":"technical/radial/#DataEnvelopmentAnalysis.dea","page":"Radial Models","title":"DataEnvelopmentAnalysis.dea","text":"dea(X, Y)\n\nCompute the radial model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\ndisposX=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\ndisposY=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\njulia> Y = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\njulia> dea(X, Y)\nRadial DEA Model \nDMUs = 11; Inputs = 2; Outputs = 1\nOrientation = Input; Returns to Scale = CRS\n──────────────────────────────────────────────────\n    efficiency       slackX1      slackX2  slackY1\n──────────────────────────────────────────────────\n1     1.0        0.0          0.0              0.0\n2     0.62229   -4.41868e-15  0.0              0.0\n3     0.819856   0.0          8.17926e-15      0.0\n4     1.0       -8.03397e-16  0.0              0.0\n5     0.310371   1.80764e-15  0.0              0.0\n6     0.555556   4.44444      0.0              0.0\n7     1.0        0.0          0.0              0.0\n8     0.757669   1.60679e-15  0.0              0.0\n9     0.820106   1.64021      0.0              0.0\n10    0.490566   9.68683e-15  0.0              0.0\n11    1.0        0.0          4.0              0.0\n──────────────────────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"technical/radial/#DataEnvelopmentAnalysis.deam","page":"Radial Models","title":"DataEnvelopmentAnalysis.deam","text":"deam(X, Y)\n\nCompute the radial multiplier model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/radialbigdata/#Radial-Big-Data-Models","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"","category":"section"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"When the number of decision-making units is large, traditional DEA models are slow to solve. Khezrimotlagh, Zhu, Cook, and Toloo (2019), propose a framework that reduces the computational time by finding the set of best practices DMUs from a subsample and evaluating the rest of the decision-making units with respect to the best performers.","category":"page"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"The proposed framework includes five steps:","category":"page"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"Select a subsample of DMU.\nFind the best practices in the subsample.\nFind the exterior DMUs with respect to the hull of the best practices.\nIdentify the set of all efficient DMUs.\nCalculate performance scores as in the traditional DEA model.","category":"page"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"This example computes the Big Data radial input-oriented DEA model under variable returns to scale, using random data drawn from a uniform distribution. 500 DMUs with six inputs and four outputs in the interval (10, 20) are generated:","category":"page"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"# Generate random data\nusing DataEnvelopmentAnalysis\nusing Distributions\nusing Random\nusing StableRNGs\n\nrng = StableRNG(1234567)\nX = rand(Uniform(10, 20), 500, 6);\nY = rand(Uniform(10, 20), 500, 4);\n\n# Calculate the Big Data DEA Model\ndeabig = deabigdata(X, Y)\n\n# Get efficiency scores\nefficiency(deabig)","category":"page"},{"location":"technical/radialbigdata/#deabigdata-Function-Documentation","page":"Radial Big Data Models","title":"deabigdata Function Documentation","text":"","category":"section"},{"location":"technical/radialbigdata/","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"deabigdata","category":"page"},{"location":"technical/radialbigdata/#DataEnvelopmentAnalysis.deabigdata","page":"Radial Big Data Models","title":"DataEnvelopmentAnalysis.deabigdata","text":"deabigdata(X, Y)\n\nCompute the big data radial model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"economic/cost/#Cost-Models","page":"Cost Models","title":"Cost Models","text":"","category":"section"},{"location":"economic/cost/#Cost-Efficiency-Model-with-Radial-Technical-Efficiency","page":"Cost Models","title":"Cost Efficiency Model with Radial Technical Efficiency","text":"","category":"section"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"Let us denote by Cleft(mathbfymathbfwright) the minimum cost of producing the output level mathbfy given the input price vector mathbfw: Cleft(mathbfymathbfwright)=min left sumlimits_i=1^mw_ix_i  mathbfx geqslant Xmathbflambda mathbfy_o leqslant Ymathbflambda mathbflambda  geqslant mathbf0 right, which considers the input possibility set capable of producing mathbfy_o. For the observed outputs levels we can calculate minimum cost and the associated optimal quantities of inputs mathbfx^* consistent with the production technology by solving the following program:","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"beginaligned\n  undersetmathbfx mathbflambda mathopmin quad quad quad  Cleft(mathbfy_mathbfwright)=mathbfwx^*   \n  textsubject textto  \n  quad quad quad quad quad  mathbfxge Xmathbflambda   \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy_o   \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"The measurement of cost efficiency assuming variable returns to scale, VRS, adds the following condition:","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"sumnolimits_j=1^nlambda_j=1","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"Cost efficiency defines as the ratio of minimum cost to observed cost: CE=Cleft(mathbfymathbfwright)mathbfwx_o. Thanks to duality results presented by Shephard (1953) , and following Farrell (1957), cost efficiency can be decomposed into the radially input oriented technical efficiency measure and the residual difference corresponding to allocative cost efficiency. Allocative  efficiency defines as the ratio between minimum cost to production cost at the technically efficient projection of the unit under evaluation.","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"In this example we compute the cost efficiency measure under variable returns to scale:","category":"page"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"julia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\njulia> deacost(X, Y, W)\nCost DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nOrientation = Input; Returns to Scale = VRS\n──────────────────────────────────\n       Cost  Technical  Allocative\n──────────────────────────────────\n1  0.615385      0.75     0.820513\n2  1.0           1.0      1.0\n3  1.0           1.0      1.0\n4  0.5           0.5      1.0\n5  0.347826      0.375    0.927536\n──────────────────────────────────","category":"page"},{"location":"economic/cost/#deacost-Function-Documentation","page":"Cost Models","title":"deacost Function Documentation","text":"","category":"section"},{"location":"economic/cost/","page":"Cost Models","title":"Cost Models","text":"deacost","category":"page"},{"location":"economic/cost/#DataEnvelopmentAnalysis.deacost","page":"Cost Models","title":"DataEnvelopmentAnalysis.deacost","text":"deacost(X, Y, W)\n\nCompute cost efficiency using data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\njulia> Y = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\njulia> W = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\njulia> deacost(X, Y, W)\nCost DEA Model \nDMUs = 5; Inputs = 2; Outputs = 2\nOrientation = Input; Returns to Scale = VRS\n──────────────────────────────────\n       Cost  Technical  Allocative\n──────────────────────────────────\n1  0.615385      0.75     0.820513\n2  1.0           1.0      1.0\n3  1.0           1.0      1.0\n4  0.5           0.5      1.0\n5  0.347826      0.375    0.927536\n──────────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Aparicio, J., Pastor, J. T., and Ray, S. C. (2013). \"An overall measure of technical inefficiency at the firm and at the industry level: the ‘lost profit on outlay’.\" European Journal of Operational Research, 226(1), 154-162.\nBanker, R., Charnes, A., and Cooper, W.W. (1984). \"Some Models for Estimating Technical and Scale Inefficiencies in Data Envelopment Analysis.\" Management Science, 30(9), 1078–1092.\nBriec, W. (1998). \"Hölder distance function and measurement of technical efficiency.\" Journal of Productivity Analysis, 11: 111–131.\nCaves D.W., Christensen L.R., Diewert, W.E. (1982). \"The Economic Theory of Index Numbers and the Measurement of Input, Output, and Productivity.\" Econometrica, 50(6), 1393–1414.\nChambers, R.G., Chung, Y., and Färe R. (1996). \"Benefit and Distance Functions.\" Journal of Economic Theory, 70(2), 407 – 419.\nChambers, R.G., Chung, Y., and Färe R. (1998). \"Profit, Directional Distance Functions, and Nerlovian Efficiency.” Journal of Optimization Theory and Applications 98(2), 351-364.\nCharnes, A., Cooper, W.W., and Rhodes, E. (1978). \"Measuring the efficiency of decision making units.\" European Journal of Operational Research, 2(6), 429–444.\nCharnes, A., Cooper, W.W., Rousseau, J. , and Semple, J. (1987). \"Data Envelopment Analyses and Axiomatic Notions of Efficiency and Reference Sets.\" Research Report, Center for Cybernetic Studies, The University of Texas at Austin.\nChavas J., and Cox, T. (1999). \"A Generalized Distance Function and the Analysis of Production Efficiency.\" Southern Economic Journal, 66(2), 294-318.\nCooper, W.W., Park, K.S. and Pastor, J.T. (1999). \"RAM: A Range Adjusted Measure of Inefficiency for Use with Additive Models, and Relations to Other Models and Measures in DEA\" Journal of Productivity Analysis 11(1), 5-42. \nCooper, W.W., and Pastor, J.T. (1995). \"Global Efficiency Measurement in DEA.” Working Paper, Depto Est e Inv. Oper. Universidad Alicante, Alicante, Spain.\nCooper, W.W., Pastor, J.T., Borras, F., Aparicio, J. and Pastor, D. (2011). \"BAM: a bounded adjusted measure of efficiency for use with bounded additive models.\" Journal of Productivity Analysis, 35(2), 85-94.\nFare, R., and Lovell, C. K. (1978). \"Measuring the technical efficiency of production.\" Journal of Economic theory, 19(1), 150-162.\nFare, R., Grosskopf, S., and Lovell,C.A.K., (1985). The Measurement of Efficiency of Production. Kluwer Nijhof Publishing.\nFare, R., Grosskopf, S., Norris, M. and Zhang, Z. (1994). \"Productivity Growth, Technical Progress, and Efficiency Change in Industrialized Countries.\" American Economic Review, 84(1), 66–83.\nFarrell, M. J. (1957). \"The Measurement of Productive Efficiency of Production.\" Journal of the Royal Statistical Society, Series A, 120(III), 253-281.\nLovell, C. A. K., and Pastor, J. T. (1995). \"Units Invariant and Translation Invariant DEA Models.\" Operations Research Letters, 18, 147–151.\nPastor, J.T., Aparicio, J., Alcaraz, J., Vidal, F. and Pastor, D. (2016). “The Reverse Directional Distance Function” in Advances in Efficiency and Productivity, edited by J. Aparicio, C.A.K. Lovell and J.T. Pastor, Springer, Cham. \nPastor, J. T., Ruiz, J. L., and Sirvent, I. (1999). \"An enhanced DEA Russell graph efficiency measure.\" European Journal of Operational Research, 115(3), 596-607.\nPastor, J.T., Lovell, C.A.K., and Aparicio, J. (2012). \"Families of linear efficiency programs based on Debreu’s loss function.\" Journal of Productivity Analysis 38(2), 109-120.\nShephard, R.W. (1953). Cost and production functions. Princeton University Press, Princeton, New Jersey.\nTone, K. (2001). \"A slacks-based measure of efficiency in data envelopment analysis.\" European Journal of Operational Research, 130(3), 498-509.\nZofío, J.L. and Prieto, A.M. (2006). \"Return to Dollar, Generalized Distance Function and the Fisher Productivity Index\" Spanish Economic Review, 8(2), 113-138.","category":"page"},{"location":"#DataEnvelopmentAnalysis.jl","page":"Home","title":"DataEnvelopmentAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataEnvelopmentAnalysis.jl is a Julia package that provides functions for efficiency and productivity measurement using Data Envelopment Analysis (DEA). Particularly, it implements a variety of technical efficiency models, economic efficiency models and productivity change models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is being developed for Julia 1.0 and above on Linux, macOS, and Windows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The packes uses internally the JuMP modelling language for mathematicall optimization with solvers GLPK and Ipopt.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"DataEnvelopmentAnalysis\")","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a tutorial on how to use the package, check the documentation on the Radial Input Oriented Model.","category":"page"},{"location":"#Available-models","page":"Home","title":"Available models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Technical efficiency DEA models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"technical/radial.md\", \"technical/radialbigdata.md\", \"technical/directional.md\", \"technical/additive.md\", \"technical/generalizeddf.md\", \"technical/russell.md\", \"technical/enhancedrussell.md\", \"technical/modifiedddf.md\", \"technical/holder.md\", \"technical/reverseddf.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Economic efficiency DEA models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"economic/cost.md\", \"economic/revenue.md\", \"economic/profit.md\", \"economic/profitability.md\"]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Productivity change models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"productivity/malmquist.md\"]\nDepth = 1","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataEnvelopmentAnalysis.jl is being developed by Javier Barbero and José Luís Zofío.","category":"page"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"CurrentModule = DataEnvelopmentAnalysis\nDocTestSetup = quote\n    using DataEnvelopmentAnalysis\nend","category":"page"},{"location":"technical/reverseddf/#Reverse-Directional-Distance-Function","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"","category":"section"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"In this example, we compute the Reverse Directional Distance Function (Pastor et al., 2016) DEA model for the Enhanced Russell Graph associated efficiency measure under variable returns to scale:","category":"page"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"julia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\njulia> dearddf(X, Y, :ERG, rts = :VRS)\nReverse DDF DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nAssociated efficiency measure = ERG\n─────────────\n   efficiency\n─────────────\n1    0.0\n2    0.0\n3    0.0\n4    0.0\n5    0.6\n6    0.52381\n7    0.142857\n8    0.8\n─────────────","category":"page"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"Estimated efficiency scores are returned with the efficiency function:","category":"page"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"julia> rddferg = dearddf(X, Y, :ERG, rts = :VRS);\n\njulia> efficiency(rddferg)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.6000000000000002\n 0.523809523809524\n 0.14285714285714296\n 0.8","category":"page"},{"location":"technical/reverseddf/#dearddf-Function-Documentation","page":"Reverse Directional Distance Function","title":"dearddf Function Documentation","text":"","category":"section"},{"location":"technical/reverseddf/","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"dearddf","category":"page"},{"location":"technical/reverseddf/#DataEnvelopmentAnalysis.dearddf","page":"Reverse Directional Distance Function","title":"DataEnvelopmentAnalysis.dearddf","text":"dearddf(X, Y, measure)\n\nCompute data envelopment analysis reverse directional distance function (RDDF) model for inputs X, outputs Y, and efficiency measure  measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n:MDDF: Modified Directional Distance Function.\n\nDirection specification:\n\nFor the Modified Directional Distance Function, the directions Gx and Gy can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nOptional Arguments\n\norient=:Graph: choose between graph oriented :Graph, input oriented :Input, or output oriented model :Output.\nrts=:CRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\nExamples\n\njulia> X = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\njulia> Y = [1; 5; 8; 9; 3; 7; 9; 2.353] ;\n\njulia> dearddf(X, Y, :ERG, orient = :Graph, rts = :VRS)\nReverse DDF DEA Model \nDMUs = 8; Inputs = 1; Outputs = 1\nOrientation = Graph; Returns to Scale = VRS\nAssociated efficiency measure = ERG\n─────────────\n   efficiency\n─────────────\n1    0.0\n2    0.0\n3    0.0\n4    0.0\n5    0.6\n6    0.52381\n7    0.142857\n8    0.8\n─────────────\n\n\n\n\n\n","category":"function"}]
}
